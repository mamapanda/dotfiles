#+TITLE: Emacs Configuration
#+AUTHOR: Daniel Phan
#+PROPERTY: header-args:emacs-lisp :tangle yes

* Table of Contents                                                     :TOC:
- [[#setup][Setup]]
  - [[#lexical-binding][Lexical Binding]]
  - [[#startup-optimizations][Startup Optimizations]]
  - [[#package-management][Package Management]]
  - [[#early-load-packages][Early Load Packages]]
  - [[#custom-file][Custom File]]
  - [[#sensitive-data][Sensitive Data]]
- [[#evil][Evil]]
  - [[#base-packages][Base Packages]]
  - [[#basic-keybindings][Basic Keybindings]]
  - [[#motions][Motions]]
  - [[#operators][Operators]]
  - [[#text-objects][Text Objects]]
  - [[#ex][Ex]]
  - [[#visual-aids][Visual Aids]]
  - [[#other][Other]]
- [[#basic-configuration][Basic Configuration]]
  - [[#variables][Variables]]
  - [[#hydras][Hydras]]
  - [[#minor-modes][Minor Modes]]
  - [[#server][Server]]
- [[#editor-packages][Editor Packages]]
  - [[#appearance][Appearance]]
  - [[#completion][Completion]]
  - [[#formatting][Formatting]]
  - [[#help][Help]]
  - [[#ivy][Ivy]]
  - [[#language-server][Language Server]]
  - [[#linting][Linting]]
  - [[#lisp][Lisp]]
  - [[#navigation][Navigation]]
  - [[#snippets][Snippets]]
  - [[#windows--buffers][Windows / Buffers]]
- [[#tools][Tools]]
  - [[#file-manager][File Manager]]
  - [[#git][Git]]
  - [[#readers][Readers]]
  - [[#shell][Shell]]
- [[#languages][Languages]]
  - [[#assembly][Assembly]]
  - [[#c--c][C / C++]]
  - [[#c][C#]]
  - [[#common-lisp][Common Lisp]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#go][Go]]
  - [[#haskell][Haskell]]
  - [[#html--css][HTML / CSS]]
  - [[#javascript--typescript][JavaScript / TypeScript]]
  - [[#json][JSON]]
  - [[#latex][Latex]]
  - [[#matlab][Matlab]]
  - [[#org][Org]]
  - [[#python][Python]]
  - [[#r][R]]
  - [[#shell-script][Shell Script]]
  - [[#other-1][Other]]
- [[#stuff-to-check-out][Stuff To Check Out]]

* Setup
** Lexical Binding
   #+BEGIN_SRC emacs-lisp
     ;; -*- lexical-binding: t; -*-
   #+END_SRC

** Startup Optimizations
   These optimizations are from [[https://github.com/hlissner/doom-emacs][Doom Emacs]].  On Emacs 26.3, it decreases my init
   time from 1.3s to 0.9s.  This hasn't really mattered that much ever since I
   enabled ~desktop.el~ though.

   #+BEGIN_SRC emacs-lisp
     (defvar panda--pre-init-file-name-handler-alist file-name-handler-alist
       "The value of `file-name-handler-alist' before init.el was loaded.")

     (defvar panda--pre-init-gc-cons-threshold gc-cons-threshold
       "The value of `gc-cons-threshold' before init.el was loaded.")

     (defun panda--restore-init-optimization-variables ()
       "Restore variables that were modified for init time optimization."
       (setq file-name-handler-alist panda--pre-init-file-name-handler-alist
             gc-cons-threshold panda--pre-init-gc-cons-threshold))

     (setq file-name-handler-alist nil
           gc-cons-threshold 64000000)

     (add-hook 'after-init-hook #'panda--restore-init-optimization-variables)
   #+END_SRC

** Package Management
   Unlike ~package.el~, ~straight.el~ has a lockfile feature to ensure
   reproducibility, which is pretty nice for configuration stability.  I grabbed
   the bootstrap code from ~straight.el~'s [[https://github.com/raxod502/straight.el#getting-started][readme]].

   #+BEGIN_SRC emacs-lisp
     (setq package-enable-at-startup nil
           straight-check-for-modifications '(check-on-save find-when-checking))

     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
   #+END_SRC

   Also, ~use-package~ for convenience.

   #+BEGIN_SRC emacs-lisp
     (straight-use-package 'use-package)
     (require 'use-package)
     (setq straight-use-package-by-default t)
   #+END_SRC

** Early Load Packages
   These are packages to load at the very beginning, since they're used
   throughout my configuration.  There's also ~evil~, but it's in its own
   section.

   #+BEGIN_SRC emacs-lisp
     (require 'cl-lib)

     (use-package el-patch)

     (use-package general
       :config
       (defalias 'gsetq #'general-setq)
       (defalias 'gsetq-default #'general-setq-default)
       (defalias 'gsetq-local #'general-setq-local))

     (use-package no-littering)

     (use-package hydra
       :config
       (gsetq hydra-look-for-remap t))

     (use-package pretty-hydra)
   #+END_SRC

** Custom File
   Set ~custom-file~ to avoid clutter.

   #+BEGIN_SRC emacs-lisp
     (gsetq custom-file (no-littering-expand-var-file-name "custom.el"))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Sensitive Data
   ~private.el~ just sets some variables that I don't want to share.

   #+BEGIN_SRC emacs-lisp
     (load-file (no-littering-expand-etc-file-name "private.el"))
   #+END_SRC

* Evil
** Base Packages
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :init
       (gsetq evil-respect-visual-line-mode t
              evil-want-keybinding nil)
       :config
       (gsetq evil-disable-insert-state-bindings t
              evil-ex-substitute-global t
              evil-goto-definition-functions '(evil-goto-definition-xref
                                               evil-goto-definition-imenu)
              evil-jumps-cross-buffers t
              evil-move-beyond-eol t
              evil-toggle-key "C-s-+"
              evil-undo-system 'undo-fu
              evil-want-C-d-scroll t
              evil-want-C-u-scroll t
              evil-want-Y-yank-to-eol t)
       (gsetq-default evil-symbol-word-search t)
       (general-create-definer panda-space
         :states '(normal operator motion visual)
         :keymaps 'override
         :prefix "SPC")
       (add-hook 'prog-mode-hook #'hs-minor-mode)
       (evil-mode 1))

     (use-package undo-fu
       :general
       (panda-space "u" #'undo-fu-disable-checkpoint)
       :config
       (gsetq undo-fu-ignore-keyboard-quit t))

     (use-package evil-collection
       :config
       (gsetq evil-collection-key-blacklist '("SPC"))
       (delete 'company evil-collection-mode-list)
       (delete 'ggtags evil-collection-mode-list)
       (evil-collection-init))
   #+END_SRC

** Basic Keybindings
   These are ~evil~ keybindings that don't depend on any additional
   packages/configuration.

   #+BEGIN_SRC emacs-lisp
     (general-def '(normal motion) override
       ";" #'evil-ex
       ":" #'eval-expression
       "," #'execute-extended-command)

     (panda-space
       ";" #'evil-repeat-find-char
       "," #'evil-repeat-find-char-reverse)
   #+END_SRC

   Swap ~`~ and ~​'​~ because I never use the default ~​'​~.

   #+BEGIN_SRC emacs-lisp
     (general-def 'motion
       "`" #'evil-goto-mark-line
       "'" #'evil-goto-mark)
   #+END_SRC

   Move redo to ~U~, since ~U~ isn't even used.

   #+BEGIN_SRC emacs-lisp
     (general-unbind 'normal "C-r")
     (general-def 'normal "U" #'evil-redo)
   #+END_SRC

   Additional navigation commands from Emacs.

   #+BEGIN_SRC emacs-lisp
     (general-def 'motion
       "[e" #'previous-error
       "]e" #'next-error
       "M-h" #'beginning-of-defun
       "M-l" #'end-of-defun
       "H" #'backward-sexp
       "L" #'forward-sexp)
   #+END_SRC

   ~<escape>~ has to be bound to ~minibuffer-keyboard-quit~ in the minibuffer.
   Otherwise, in some cases, it has to be pressed multiple times due to ~C-g~
   being the standard Emacs quit key.

   #+BEGIN_SRC emacs-lisp
     (general-def minibuffer-local-map
       "<escape>" #'minibuffer-keyboard-quit)
   #+END_SRC

   Leader bindings.  Most of these already have default Emacs bindings, but it's
   more convenient to not have to press any modifiers.  For ~%~, using
   ~general-key~ with ~C-x C-q~ allows that particular binding to also work with
   ~occur~ and ~dired~.

   #+BEGIN_SRC emacs-lisp
     (panda-space
       "b" #'switch-to-buffer                ; C-x b
       "c" #'compile
       "f" #'find-file                       ; C-x C-f
       "h" #'help-command                    ; C-h
       "o" #'occur                           ; M-s o
       "%" (general-key "C-x C-q")           ; C-x C-q
       "-" #'delete-trailing-whitespace)
   #+END_SRC

   I've disabled the insert state bindings in favor of using Emacs keys in
   insert mode.  These are the insert state commands I'd like to keep.

   #+BEGIN_SRC emacs-lisp
     (general-def 'insert
       "<C-backspace>" #'evil-delete-backward-word
       "C-x r i" #'evil-paste-from-register
       "M-o" #'evil-execute-in-normal-state)
   #+END_SRC

   ~evil-ex~ uses keys different from most other minibuffer commands (e.g. ~C-n~
   instead of ~M-n~), which can be pretty confusing.  I've changed it to match.

   #+BEGIN_SRC emacs-lisp
     (setf (cdr evil-ex-completion-map) (cdr (copy-keymap minibuffer-local-map)))

     (general-def evil-ex-completion-map
       "TAB" #'evil-ex-completion
       "C-x r i" #'evil-paste-from-register)
   #+END_SRC

** Motions
   #+BEGIN_SRC emacs-lisp
     (use-package evil-easymotion
       :general
       ('(normal motion) "s" '(:keymap evilem-map))
       (evilem-map "f" #'panda-em-snipe-s
                   "F" #'panda-em-snipe-S
                   "t" #'panda-em-snipe-x
                   "T" #'panda-em-snipe-X)
       :config
       (defmacro panda-make-snipe-easymotion (name snipe-motion)
         `(evilem-make-motion ,name #'evil-snipe-repeat
                              :pre-hook (save-excursion (call-interactively ,snipe-motion))
                              :bind ((evil-snipe-enable-highlight nil)
                                     (evil-snipe-enable-incremental-highlight nil))))
       (panda-make-snipe-easymotion panda-em-snipe-s #'evil-snipe-s)
       (panda-make-snipe-easymotion panda-em-snipe-S #'evil-snipe-S)
       (panda-make-snipe-easymotion panda-em-snipe-x #'evil-snipe-x)
       (panda-make-snipe-easymotion panda-em-snipe-X #'evil-snipe-X)
       ;; Just redefine these instead of defining new motions and remapping
       (evilem-make-motion evilem-motion-forward-word-begin #'evil-forward-word-begin)
       (evilem-make-motion evilem-motion-forward-word-end #'evil-forward-word-end)
       (evilem-make-motion evilem-motion-backward-word-begin #'evil-backward-word-begin)
       (evilem-make-motion evilem-motion-forward-WORD-begin #'evil-forward-WORD-begin)
       (evilem-make-motion evilem-motion-forward-WORD-end #'evil-forward-WORD-end)
       (evilem-make-motion evilem-motion-backward-WORD-begin #'evil-backward-WORD-begin))

     (use-package evil-matchit
       :config
       (global-evil-matchit-mode 1))

     (use-package evil-snipe
       :demand t
       :general
       (general-unbind 'motion evil-snipe-override-local-mode-map ";" ",")
       ('(normal motion) evil-snipe-override-local-mode-map
        "f" #'evil-snipe-s
        "F" #'evil-snipe-S
        "t" #'evil-snipe-x
        "T" #'evil-snipe-X
        [remap evil-repeat-find-char] #'evil-snipe-repeat
        [remap evil-repeat-find-char-reverse] #'evil-snipe-repeat-reverse)
       :config
       (gsetq evil-snipe-smart-case t
              evil-snipe-scope 'visible
              evil-snipe-repeat-scope 'visible
              evil-snipe-tab-increment t)
       (evil-snipe-override-mode 1))
   #+END_SRC

** Operators
   #+BEGIN_SRC emacs-lisp
     (use-package evil-exchange
       :config
       (evil-exchange-install))

     (use-package evil-lion
       :general
       ('normal "gl" #'evil-lion-left
                "gL" #'evil-lion-right))

     (use-package evil-nerd-commenter
       :general
       ('normal "gc" #'evilnc-comment-operator
                "gy" #'evilnc-copy-and-comment-operator)
       ('inner "c" #'evilnc-inner-comment)
       ('outer "c" #'evilnc-outer-commenter))

     (use-package evil-replace-with-register
       :general ('normal "gR" #'evil-replace-with-register))
   #+END_SRC

   Custom keybindings for the following packages need to be configured /after/
   the packages are loaded.

   #+BEGIN_SRC emacs-lisp
     (use-package evil-string-inflection
       :config
       (general-def 'normal
         "g~" #'evil-invert-case
         "g`" #'evil-operator-string-inflection))

     (use-package evil-surround
       :config
       (setf (cdr evil-surround-mode-map) nil)
       (general-def 'operator evil-surround-mode-map
         "gs" #'evil-surround-edit
         "gS" #'evil-Surround-edit)
       (general-def 'visual evil-surround-mode-map
         "gs" #'evil-surround-region
         "gS" #'evil-Surround-region)
       (global-evil-surround-mode 1))
   #+END_SRC

** Text Objects
*** Packages
    #+BEGIN_SRC emacs-lisp
      (use-package evil-args
        :general
        ('inner "a" #'evil-inner-arg)
        ('outer "a" #'evil-outer-arg))

      (use-package evil-indent-plus
        :config
        (evil-indent-plus-default-bindings))

      (use-package evil-textobj-column
        :general
        ('(inner outer) "k" #'evil-textobj-column-word)
        ('(inner outer) "K" #'evil-textobj-column-WORD))

      (use-package targets
        :straight (:type git :host github :repo "noctuid/targets.el")
        :config
        (targets-setup t))
    #+END_SRC

*** Buffer
    I could define a remote buffer object that prompts for a buffer, but I don't
    see myself using that outside of cases already covered by ~:read~.

    #+BEGIN_SRC emacs-lisp
      (evil-define-text-object panda-outer-buffer (count beg end type)
        "Select the whole buffer."
        :type line
        (evil-range (point-min) (point-max)))

      (defalias 'panda-inner-buffer #'panda-outer-buffer)

      (general-def 'outer "e" #'panda-outer-buffer)
      (general-def 'inner "e" #'panda-inner-buffer)
    #+END_SRC

*** Defun
    The outer version of this text object selects a whole function definition,
    while the inner version selects the body (e.g. inside the braces in C).

    #+BEGIN_SRC emacs-lisp
      (defvar-local panda-inner-defun-bounds '("{" . "}")
        "Variable to determine the bounds of an inner defun.
      The value can be a pair of regexps to determine the start and end,
      exclusive of the matched expressions.  It can also be a function, in
      which case the return value will be used.")

      (defun panda--in-sexp-p  (pos)
        "Check if POS is inside a sexp."
        (save-excursion
          (goto-char pos)
          (condition-case nil
              (progn
                (up-list 1 t t)
                t)
            (scan-error nil))))

      (defun panda--inner-defun-bounds (defun-begin defun-end open-regexp close-regexp)
        "Find the beginning and end of an inner defun.
      DEFUN-BEGIN and DEFUN-END are the bounds of the defun.  OPEN-REGEXP
      and CLOSE-REGEXP match the delimiters of the inner defun."
        ;; Some default parameter values (e.g. "{") can conflict with the open regexp.
        ;; However, they're usually nested in some sort of sexp, while the intended
        ;; match usually isn't.  For the close regexp, I can't think of a single
        ;; conflict case, since it's usually also the function's end.
        (save-excursion
          (save-match-data
            (let ((begin (progn
                           (goto-char defun-begin)
                           (re-search-forward open-regexp defun-end)
                           (while (save-restriction
                                    (narrow-to-region defun-begin defun-end)
                                    (panda--in-sexp-p (match-beginning 0)))
                             (re-search-forward open-regexp defun-end))
                           (skip-chars-forward "[:blank:]")
                           (when (eolp)
                             (forward-char))
                           (point)))
                  (end (progn
                         (goto-char defun-end)
                         (re-search-backward close-regexp defun-begin)
                         (skip-chars-backward "[:blank:]")
                         (when (bolp)
                           (backward-char))
                         (point))))
              (cons begin end)))))

      (defun panda--shrink-inner-defun (range)
        "Shrink RANGE to that of an inner defun."
        (cl-destructuring-bind (begin . end)
            (cond
             ((consp panda-inner-defun-bounds)
              (panda--inner-defun-bounds (evil-range-beginning range)
                                         (evil-range-end range)
                                         (car panda-inner-defun-bounds)
                                         (cdr panda-inner-defun-bounds)))
             ((functionp panda-inner-defun-bounds)
              (funcall panda-inner-defun-bounds
                       (evil-range-beginning range)
                       (evil-range-end range))))
          (evil-range begin end
                      (and (= (char-before begin) (char-after end) ?\n) 'line))))

      (put 'defun 'targets-no-extend t)     ; seems like defun doesn't work otherwise
      (put 'defun 'targets-shrink-inner-op #'panda--shrink-inner-defun)

      (targets-define-to defun 'defun nil object :linewise t :bind t :keys "d")
    #+END_SRC

*** Line
    #+BEGIN_SRC emacs-lisp
      (targets-define-to line 'line nil object :bind t :keys "L")
    #+END_SRC

*** Whitespace
    I got a little tired of pressing ~M-SPC~.

    #+BEGIN_SRC emacs-lisp
      (defun forward-panda-whitespace (count)
        "Move forward COUNT horizontal whitespace blocks."
        (evil-forward-chars "[:blank:]" count))

      (defun panda--shrink-inner-whitespace (range)
        "Shrink RANGE to not include the first whitespace character."
        (evil-set-range-beginning range (1+ (evil-range-beginning range))))

      (put 'panda-whitespace 'targets-no-extend t) ; doesn't make sense to extend
      (put 'panda-whitespace 'targets-shrink-inner-op #'panda--shrink-inner-whitespace)

      (targets-define-to whitespace 'panda-whitespace nil object :bind t :keys " ")
    #+END_SRC

*** Whitespace Line
    I forgot why I wrote this.  At the moment, the remote text object doesn't
    pick up whitespace lines at the very beginning of a buffer, even though the
    regular/last objects work just fine.

    #+BEGIN_SRC emacs-lisp
      (defun forward-panda-whitespace-line (count)
        "Move forward COUNT whitespace-only lines."
        (condition-case nil
            (evil-forward-not-thing 'evil-paragraph count)
          (wrong-type-argument))) ; might happen at the end of the buffer

      (defun panda--shrink-inner-whitespace-line (range)
        "Shrink RANGE to not include the trailing newline."
        (evil-set-range-end range (1- (evil-range-end range))))

      (put 'panda-whitespace-line 'targets-no-extend t) ; doesn't make sense to extend
      (put 'panda-whitespace-line 'targets-shrink-inner-op #'panda--shrink-inner-whitespace-line)

      (targets-define-to whitespace-line 'panda-whitespace-line nil object
                         :bind t :keys "\^M" :linewise t)
    #+END_SRC

** Ex
   #+BEGIN_SRC emacs-lisp
     (defun panda-static-evil-ex (&optional initial-input)
       "`evil-ex' that doesn't move point."
       (interactive)
       (save-excursion (call-interactively #'evil-ex)))

     (general-def [remap evil-ex] #'panda-static-evil-ex)

     (evil-ex-define-cmd "n" "normal")

     (defun panda-kill-this-buffer ()
       "Kill the current buffer."
       (interactive)
       (kill-buffer (current-buffer)))

     (evil-ex-define-cmd "bk[ill]" #'panda-kill-this-buffer)

     (defun panda-reload-file ()
       "Reload the current file, preserving point."
       (interactive)
       (if buffer-file-name
           (let ((pos (point)))
             (find-alternate-file buffer-file-name)
             (goto-char pos))
         (message "Buffer is not visiting a file")))

     (evil-ex-define-cmd "reload" #'panda-reload-file)

     (defun panda-sudo-reload-file ()
       "Reload the current file with root privileges, preserving point."
       (interactive)
       (if buffer-file-name
           (let ((pos (point)))
             (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))
             (goto-char pos))
         (message "Buffer is not visiting a file")))

     (evil-ex-define-cmd "sudoreload" #'panda-sudo-reload-file)
   #+END_SRC

** Visual Aids
   Feedback from ~evil-goggles~ and ~evil-traces~ lets me know that I executed
   the correct command.  Also, 99% of the time, I can't remember which
   marks/registers contain what, so ~evil-owl~ is really useful.

   #+BEGIN_SRC emacs-lisp
     (use-package evil-goggles
       :config/el-patch
       ;; The = register prompt will linger without this patch.
       ;; Probably warrants a PR.
       (el-patch-defun evil-goggles--paste-vert-block-p (register yank-handler)
         "Return t if the paste is a vertical block.

     Argument REGISTER is the evil register.
     Argument YANK-HANDLER is the yank hanler."
         (let* ((text (el-patch-swap
                        (if register
                            (evil-get-register register)
                          (current-kill 0))
                        (cond
                         ((eq register ?=) evil-last-=-register-input)
                         (register (evil-get-register register))
                         (t (current-kill 0)))))
                (yh (or yank-handler
                        (when (stringp text)
                          (car-safe (get-text-property
                                     0 'yank-handler text))))))
           (eq yh 'evil-yank-block-handler)))
       :config
       (gsetq evil-goggles-pulse nil)
       (defun panda-evil-goggles-add (cmd based-on-cmd)
         "Register CMD with evil-goggles using BASED-ON-CMD's configuration."
         (when-let ((cmd-config (alist-get based-on-cmd evil-goggles--commands)))
           (add-to-list 'evil-goggles--commands (cons cmd cmd-config))
           (when (bound-and-true-p evil-goggles-mode)
             (evil-goggles-mode 1))))
       (evil-goggles-use-diff-refine-faces)
       (evil-goggles-mode 1))

     (use-package evil-owl
       :straight (evil-owl
                  :host nil
                  :repo "git@github.com:mamapanda/evil-owl.git")
       :custom-face
       (evil-owl-group-name ((t (
                                 :inherit font-lock-function-name-face
                                 :weight bold
                                 :underline t))))
       (evil-owl-entry-name ((t (:inherit font-lock-function-name-face))))
       :config
       (gsetq evil-owl-display-method 'posframe
              evil-owl-global-mark-format " %m: [l: %-5l, c: %-5c] %b\n  %s"
              evil-owl-local-mark-format " %m: [l: %-5l, c: %-5c]\n  %s"
              evil-owl-register-char-limit 50
              evil-owl-idle-delay 0.2)
       (gsetq evil-owl-extra-posframe-args
              `(
                :poshandler posframe-poshandler-point-bottom-left-corner
                :width 50
                :height 20
                :internal-border-width 2))
       (evil-owl-mode))

     (use-package evil-traces
       :straight (evil-traces
                  :host nil
                  :repo "git@github.com:mamapanda/evil-traces.git")
       :config
       (defun panda-no-ex-range-and-arg-p ()
         "Return non-nil if both `evil-ex-range' and `evil-ex-argument' are nil."
         (and (null evil-ex-range) (null evil-ex-argument)))
       (gsetq evil-traces-suspend-function #'panda-no-ex-range-and-arg-p)
       (evil-traces-use-diff-faces)
       (evil-traces-mode))
   #+END_SRC

** Other
   #+BEGIN_SRC emacs-lisp
     (use-package evil-numbers
       :straight (:host github :repo "janpath/evil-numbers")
       :general
       ('normal "C-a" #'evil-numbers/inc-at-pt
                "C-s" #'evil-numbers/dec-at-pt
                "g C-a" #'evil-numbers/inc-at-pt-incremental
                "g C-s" #'evil-numbers/dec-at-pt-incremental))
   #+END_SRC

   Evil's markers aren't saved with ~desktop.el~ by default.  I tried to fix it,
   but my solution isn't consistent.  Sometimes, the marks aren't saved or point
   to the wrong locations.

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'desktop
       (defvar panda--default-markers-alist nil)
       (cl-pushnew 'evil-markers-alist desktop-locals-to-save)
       (cl-pushnew 'panda--default-markers-alist desktop-globals-to-save)
       (add-hook 'desktop-save-hook
                 (lambda ()
                   (setq panda--default-markers-alist (default-value 'evil-markers-alist))))
       (add-hook 'desktop-after-read-hook
                 (lambda ()
                   (setf (default-value 'evil-markers-alist) panda--default-markers-alist))))
   #+END_SRC

* Basic Configuration
  This section is for additional configuration that doesn't rely on packages
  other than the ones in [[*Setup]["Setup"]].

** Variables
   #+BEGIN_SRC emacs-lisp
     (gsetq auto-save-default t
            blink-cursor-blinks 0
            c-default-style '((java-mode . "java")
                              (awk-mode . "awk")
                              (other . "stroustrup"))
            default-frame-alist '((fullscreen . maximized)
                                  (font . "Consolas-11")
                                  (menu-bar-lines . 0)
                                  (tool-bar-lines . 0)
                                  (vertical-scroll-bars . nil))
            delete-by-moving-to-trash t
            disabled-command-function nil
            enable-recursive-minibuffers t
            inhibit-compacting-font-caches t
            inhibit-startup-screen t
            make-backup-files nil
            recentf-max-saved-items 500
            require-final-newline t
            ring-bell-function 'ignore
            save-abbrevs nil
            tramp-default-method "ssh"
            undo-limit 1000000
            use-dialog-box nil
            vc-follow-symlinks t
            visible-bell nil)

     (gsetq-default bidi-display-reordering nil
                    buffer-file-coding-system 'utf-8
                    c-basic-offset 4
                    fill-column 80
                    indent-tabs-mode nil
                    tab-width 4
                    truncate-lines nil)
   #+END_SRC

** Hydras
   #+BEGIN_SRC emacs-lisp
     (pretty-hydra-define panda-package-hydra (:title "Packages" :color teal :quit-key "<escape>")
       ("Build"
        (("r" straight-rebuild-package "rebuild package")
         ("R" straight-rebuild-all "rebuild all")
         ("m" straight-check-package "rebuild package if modified")
         ("M" straight-check-all "rebuild all if modified")
         ("p" straight-prune-build "prune build cache/dir"))
        "Update"
        (("p" straight-pull-package "pull package")
         ("C-p" straight-pull-package-and-deps "pull package and deps")
         ("P" straight-pull-all "pull all")
         ("n" straight-normalize-package "normalize package")
         ("N" straight-normalize-all "normalize all"))
        "Install"
        (("u" straight-use-package "use package"))
        "Lockfile"
        (("s" straight-freeze-versions "save versions")
         ("a" straight-thaw-versions "apply versions"))
        "Other"
        (("w" straight-visit-package-website "visit package website"))))

     (panda-space "z" #'panda-package-hydra/body)
   #+END_SRC

** Minor Modes
   #+BEGIN_SRC emacs-lisp
     (blink-cursor-mode)
     (column-number-mode)
     (delete-selection-mode)
     (desktop-save-mode)
     (electric-pair-mode)
     (global-auto-revert-mode)
     (recentf-mode)
     (show-paren-mode)
   #+END_SRC

** Server
   #+BEGIN_SRC emacs-lisp
     (require 'server)
     (unless (server-running-p)
       (server-start))
   #+END_SRC

* Editor Packages
** Appearance
   #+BEGIN_SRC emacs-lisp
     (use-package doom-themes
       :config
       (load-theme 'doom-vibrant t))

     (use-package display-line-numbers
       :general (panda-space "l" #'global-display-line-numbers-mode))

     (use-package doom-modeline
       :config
       (gsetq doom-modeline-buffer-file-name-style 'relative-from-project
              doom-modeline-icon nil
              doom-modeline-unicode-fallback nil)
       (set-face-attribute 'doom-modeline-bar nil
                           :background (face-attribute 'mode-line :background))
       (set-face-attribute 'doom-modeline-inactive-bar nil
                           :background (face-attribute 'mode-line-inactive :background))
       (doom-modeline-mode 1))

     (use-package hl-todo
       :config
       (global-hl-todo-mode))

     (use-package posframe
       :defer t
       :config
       (gsetq posframe-mouse-banish nil)
       (set-face-background 'internal-border (face-foreground 'font-lock-comment-face)))

     (use-package rainbow-delimiters
       :ghook 'prog-mode-hook)

     (use-package all-the-icons :defer t)
   #+END_SRC

** Completion
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :config
       (gsetq company-idle-delay 0.2
              company-minimum-prefix-length 2
              company-tooltip-align-annotations t)
       (global-company-mode))

     (use-package company-box
       :ghook 'company-mode-hook
       :config
       (gsetq company-box-icons-alist 'company-box-icons-all-the-icons))
   #+END_SRC

** Formatting
   I like having my code auto-formatted on save so I don't have to think about
   code style at all.  It's one less thing to worry about when programming.

   For languages with formatters I like, I use ~reformatter~.  There are other
   packages that already provide good integration, such as ~clang-format~, but I
   prefer ~reformatter~'s simplicity.  When possible, I use external
   configuration files so that options apply outside of Emacs as well.

   #+BEGIN_SRC emacs-lisp
     (use-package reformatter)
   #+END_SRC

   For other languages, I have two simple minor modes.

   #+BEGIN_SRC emacs-lisp
     (defun panda-format-buffer ()
       "Indent the entire buffer and delete trailing whitespace."
       (interactive)
       (let ((inhibit-message t))
         (indent-region (point-min) (point-max))
         (delete-trailing-whitespace)))

     (panda-space "=" #'panda-format-buffer)

     (define-minor-mode panda-format-on-save-mode
       "Indents a buffer and trims whitespace on save."
       :init-value nil
       :lighter "panda-format"
       (if panda-format-on-save-mode
           (add-hook 'before-save-hook #'panda-format-buffer nil t)
         (remove-hook 'before-save-hook #'panda-format-buffer t)))

     (define-minor-mode panda-trim-on-save-mode
       "Trims whitespace on save."
       :init-value nil
       :lighter "panda-trim"
       (if panda-trim-on-save-mode
           (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
         (remove-hook 'before-save-hook #'delete-trailing-whitespace t)))
   #+END_SRC

** Help
   #+BEGIN_SRC emacs-lisp
     (use-package helpful
       :general
       (help-map "f" #'helpful-callable
                 "k" #'helpful-key
                 "v" #'helpful-variable))
   #+END_SRC

** Ivy
   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :demand t
       :general
       (ivy-minibuffer-map
        "<return>" #'ivy-alt-done
        "C-<return>" #'ivy-immediate-done)
       :config
       (gsetq ivy-wrap t
              ivy-re-builders-alist '((swiper . ivy--regex-plus)
                                      (t . ivy--regex-fuzzy))
              ivy-use-virtual-buffers t
              ivy-count-format "(%d/%d) ")
       (with-eval-after-load 'projectile
         (gsetq projectile-completion-system 'ivy))
       (ivy-mode))

     (use-package counsel
       :demand t
       :general
       (panda-space "S" #'counsel-git-grep)
       :config
       (counsel-mode))

     (use-package swiper
       :general ('normal "g?" #'swiper))

     (use-package ivy-hydra :defer t)

     (use-package ivy-prescient
       :after ivy
       :config
       (gsetq ivy-prescient-retain-classic-highlighting t)
       (prescient-persist-mode)
       (ivy-prescient-mode))

     (use-package ivy-rich
       :after ivy
       :config
       (gsetq ivy-rich-parse-remote-buffer nil
              ivy-rich-parse-remote-file-path nil)
       (ivy-rich-mode))

     (use-package ivy-posframe
       :disabled t
       :after ivy
       :config
       (gsetq ivy-posframe-border-width 1
              ivy-posframe-display-functions-alist
              '((swiper . ivy-display-function-fallback)
                (t . ivy-posframe-display-at-point)))
       (ivy-posframe-mode))

     (use-package counsel-projectile
       :after counsel projectile
       :config
       (counsel-projectile-mode))

     (use-package lsp-ivy
       :after ivy lsp-mode
       :general
       (lsp-ui-mode-map [remap lsp-ui-find-workspace-symbol] #'lsp-ivy-workspace-symbol))

     (use-package ivy-xref
       :after ivy xref
       :config
       (gsetq xref-show-xrefs-function #'ivy-xref-show-xrefs))
   #+END_SRC

** Language Server
   ~lsp-ui~'s sideline diagnostics are disabled in favor of ~flycheck-posframe~
   to keep the error UI consistent across all languages.  LSP formatting is also
   disabled in favor of ~reformatter~.

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :defer t
       :general
       ('normal lsp-mode-map
                "gd" #'lsp-find-definition
                "gD" #'lsp-find-references
                "K" #'lsp-describe-thing-at-point)
       :config
       (gsetq lsp-auto-execute-action nil
              lsp-before-save-edits nil
              lsp-enable-indentation nil
              lsp-enable-on-type-formatting nil
              lsp-headerline-breadcrumb-enable nil
              lsp-prefer-flymake nil))

     (use-package lsp-ui
       :after lsp-mode
       :config
       (gsetq lsp-ui-doc-position 'top
              lsp-ui-peek-always-show t
              lsp-ui-sideline-show-diagnostics nil))

     (use-package dap-mode
       :commands dap-debug dap-hydra
       :config
       (require 'dap-chrome)
       (require 'dap-firefox)
       (require 'dap-gdb-lldb)
       (require 'dap-python)
       (dap-mode 1)
       (dap-ui-mode 1))

     (with-eval-after-load 'major-mode-hydra
       (defvar panda--lsp-hydra-enabled-modes nil
         "Major modes that already have lsp hydra heads.")
       (defun panda--add-lsp-hydra-heads ()
         "Add `lsp' command heads to the current major mode's `major-mode-hydra'."
         (unless (memq major-mode panda--lsp-hydra-enabled-modes)
           (eval
            `(major-mode-hydra-define+ ,major-mode nil
               ("Navigate"
                (("s" lsp-ui-find-workspace-symbol "Workspace Symbol")
                 ("i" lsp-ui-imenu "Imenu"))
                "Refactor"
                (("r" lsp-rename "Rename")
                 ("c" lsp-ui-sideline-apply-code-actions "Code Action")
                 ("o" lsp-organize-imports "Organize Imports"))
                "View"
                (("l" lsp-lens-mode "Lens")
                 ("E" lsp-ui-flycheck-list "Errors"))
                "Debug"
                (("D" dap-debug "Start")
                 ("d" dap-hydra "Hydra"))
                "Workspace"
                (("<backspace>" lsp-restart-workspace "Restart")
                 ("<delete>" lsp-shutdown-workspace "Shutdown")))))
           (push major-mode panda--lsp-hydra-enabled-modes)))
       (add-hook 'lsp-mode-hook #'panda--add-lsp-hydra-heads))
   #+END_SRC

** Linting
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :demand t
       :general
       (flycheck-mode-map
        [remap previous-error] #'flycheck-previous-error
        [remap next-error] #'flycheck-next-error)
       :config
       (gsetq flycheck-display-errors-delay 0.5)
       (evil-declare-motion #'flycheck-previous-error)
       (evil-declare-motion #'flycheck-next-error)
       (global-flycheck-mode))

     (use-package flycheck-posframe
       :ghook 'flycheck-mode-hook
       :config
       (flycheck-posframe-configure-pretty-defaults))
   #+END_SRC

** Lisp
   #+BEGIN_SRC emacs-lisp
     (use-package lispyville
       :defer t
       :config
       (lispyville-set-key-theme '(c-w
                                   commentary
                                   operators
                                   prettify
                                   slurp/barf-cp))
       (general-unbind 'motion lispyville-mode-map "{" "}")
       (with-eval-after-load 'evil-goggles
         (panda-evil-goggles-add #'lispyville-yank #'evil-yank)
         (panda-evil-goggles-add #'lispyville-delete #'evil-delete)
         (panda-evil-goggles-add #'lispyville-change #'evil-change)
         (panda-evil-goggles-add #'lispyville-yank-line #'evil-yank-line)
         (panda-evil-goggles-add #'lispyville-delete-line #'evil-delete-line)
         (panda-evil-goggles-add #'lispyville-change-line #'evil-change-line)
         (panda-evil-goggles-add #'lispyville-change-whole-line #'evil-change-whole-line)
         (panda-evil-goggles-add #'lispyville-join #'evil-join)))

     (use-package lispy
       :ghook 'lispyville-mode-hook
       :config
       (lispy-set-key-theme '(lispy special))
       (lispy-define-key lispy-mode-map-special "<" #'lispy-slurp-or-barf-left)
       (lispy-define-key lispy-mode-map-special ">" #'lispy-slurp-or-barf-right)
       (general-def lispy-mode-map-lispy "\"" #'lispy-doublequote))
   #+END_SRC

** Navigation
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :general
       ('motion "g/" #'avy-goto-char-timer)
       (evil-ex-completion-map "C-l" #'panda-ex-avy-insert-line)
       :config
       (gsetq avy-all-windows nil
              avy-all-windows-alt t
              avy-background t)
       (defun panda-ex-avy-insert-line ()
         "Use avy to select a line number, then insert the line number as text.
     For use with `evil-ex'."
         (interactive)
         (when-let ((line
                     (with-selected-window (get-mru-window)
                       (save-excursion
                         (when (avy-goto-line)
                           (line-number-at-pos))))))
           (insert (format "%d" line)))))

     (use-package deadgrep
       :general (panda-space "s" #'deadgrep)
       :config
       (defun panda-deadgrep-project-root ()
         "Find the root directory of the current project."
         (or (and (require 'projectile nil t) (projectile-project-root))
             default-directory))
       (gsetq deadgrep-project-root-function #'panda-deadgrep-project-root)

       ;; FIXME: probably need to also modify `evil--jumps-buffer-targets'
       (evil-add-command-properties #'deadgrep-visit-result :jump t)
       (evil-add-command-properties #'deadgrep-visit-result-other-window :jump t))

     (use-package imenu
       :general (panda-space "i" #'imenu)
       :config
       (gsetq imenu-auto-rescan t))

     (use-package projectile
       :defer t
       :general (panda-space "p" '(:keymap projectile-command-map))
       :config
       (gsetq projectile-enable-caching t
              projectile-indexing-method 'alien)
       (projectile-mode))

     (use-package treemacs
       :defer t
       :general (panda-space "t" #'treemacs)
       :config
       (setq treemacs-follow-after-init t
             treemacs-is-never-other-window t))

     (use-package treemacs-all-the-icons
       :after treemacs
       :config
       (treemacs-load-theme "all-the-icons"))

     (use-package treemacs-evil :after treemacs evil)
     (use-package treemacs-projectile :after treemacs projectile)
     (use-package treemacs-magit :after treemacs magit)

     (use-package xref
       :general ('motion "gD" #'panda-xref-find-references)
       :config
       (evil-define-motion panda-xref-find-references ()
         "Like `xref-find-references' but automatically uses the identifer at point."
         :jump t
         (if-let ((identifier (xref-backend-identifier-at-point (xref-find-backend))))
             (xref-find-references identifier)
           (user-error "No symbol under cursor"))))
   #+END_SRC

** Snippets
   ~company~'s tab key can conflict with ~yasnippet~.  The fix is from [[https://stackoverflow.com/questions/2087225/about-the-fix-for-the-interference-between-company-mode-and-yasnippet][Stack
   Overflow]].

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :demand t
       :general (panda-space "y" #'yas-insert-snippet)
       :config
       (gsetq yas-triggers-in-field t
              yas-indent-line 'auto
              yas-also-auto-indent-first-line t)
       (yas-reload-all)

       (with-eval-after-load 'company
         (defun panda--company-yas-tab-advice (old-func &rest args)
           (unless (and yas-minor-mode (yas-expand))
             (call-interactively old-func args)))
         (when-let ((company-tab-func (lookup-key company-active-map (kbd "<tab>"))))
           (advice-add company-tab-func :around #'panda--company-yas-tab-advice)))

       (defun panda--insert-snippet-in-insert-mode (&rest _)
         "Advice to enter insert mode before inserting a snippet."
         (evil-insert-state))
       (advice-add 'yas-insert-snippet :before #'panda--insert-snippet-in-insert-mode)

       (yas-global-mode))

     (use-package doom-snippets
       :straight (:host github :repo "hlissner/doom-snippets" :files ("*.el" "*"))
       :after yasnippet)
   #+END_SRC

** Windows / Buffers
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons-ibuffer
       :after ibuffer
       :config
       (all-the-icons-ibuffer-mode))
   #+END_SRC

   I've changed ~doom-modeline~'s eyebrowse segment to my own segment to show
   more information about non-current workspaces.  For example, if there are
   workspaces named config (number 1), scratch (number 3), and homework (number
   4), with config being current, then the segment will display
   ~1:config|3s|4h~.  I always name my workspaces, so there's no issue with
   missing names.

   #+BEGIN_SRC emacs-lisp
     (use-package eyebrowse
       :demand t
       :general
       (panda-space
         "<tab>" #'eyebrowse-last-window-config
         "w" #'eyebrowse-switch-to-window-config
         "W" #'eyebrowse-close-window-config
         "e" #'panda-eyebrowse-create-window-config
         "E" #'eyebrowse-rename-window-config)
       ('normal eyebrowse-mode-map
                "gt" #'eyebrowse-next-window-config
                "gT" #'eyebrowse-prev-window-config)
       :init
       (defvar eyebrowse-mode-map (make-sparse-keymap))
       :config
       (gsetq eyebrowse-new-workspace t)
       (defun panda-eyebrowse-create-window-config (tag)
         (interactive "sWindow Config Tag: ")
         (eyebrowse-create-window-config)
         (let ((created-config (eyebrowse--get 'current-slot)))
           (eyebrowse-rename-window-config created-config tag)))
       (with-eval-after-load 'doom-modeline
         (doom-modeline-def-segment workspace-name
           "Custom workspace segment for doom-modeline."
           (when eyebrowse-mode
             (assq-delete-all 'eyebrowse-mode mode-line-misc-info)
             (let ((segment-face (if (doom-modeline--active)
                                     'doom-modeline-buffer-path
                                   'mode-line-inactive))
                   (current-face (if (doom-modeline--active)
                                     'doom-modeline-buffer-file
                                   'mode-line-inactive)))
               (format
                " %s "
                (mapconcat
                 (lambda (window-config)
                   (let ((slot (cl-first window-config))
                         (tag (cl-third window-config)))
                     (if (= slot (eyebrowse--get 'current-slot))
                         (propertize (format "%d:%s" slot tag) 'face current-face)
                       (propertize (format "%d%.1s" slot tag) 'face segment-face))))
                 (eyebrowse--get 'window-configs)
                 (propertize "|" 'face segment-face)))))))
       (eyebrowse-mode 1))
   #+END_SRC

   ~winner-undo~ is useful for hiding popup windows without having to navigate
   to them.

   #+BEGIN_SRC emacs-lisp
     (use-package winner
       :demand t
       :general
       (panda-space
         "q" #'winner-undo
         "Q" #'winner-redo)
       :config
       (winner-mode 1))
   #+END_SRC

* Tools
** File Manager
   ~dired~ is a pretty good file manager in my opinion, especially with Fuco1's
   [[https://github.com/Fuco1/dired-hacks/][dired-hacks]].

   #+BEGIN_SRC emacs-lisp
     (use-package dired-x
       :straight nil
       :general
       (panda-space
         "j" #'dired-jump
         "J" #'dired-jump-other-window))

     (use-package all-the-icons-dired
       :ghook 'dired-mode-hook)

     (use-package image-dired
       :general (normal dired-mode-map "C-t h" #'panda-image-dired-here)
       :config
       (defun panda-image-dired-here ()
         "Run `image-dired' in the default directory."
         (interactive)
         (image-dired default-directory)))

     (use-package dired-filter
       :defer t
       :general ('normal dired-mode-map "zf" '(:keymap dired-filter-map)))

     (use-package dired-open
       :general ('normal dired-mode-map "<C-return>" #'dired-open-xdg))

     (use-package dired-subtree
       :general
       ('normal dired-mode-map
                "zo" #'panda-dired-subtree-insert
                "zc" #'panda-dired-subtree-remove
                "za" #'dired-subtree-toggle
                "<tab>" #'dired-subtree-cycle)
       :config
       (defun panda-dired-subtree-insert ()
         "Like `dired-subtree-insert', but doesn't move point."
         (interactive)
         (save-excursion
           (dired-subtree-insert)))
       (defun panda-dired-subtree-remove ()
         "Like `dired-subtree-remove', but removes the current node's children."
         (interactive)
         (when (dired-subtree--is-expanded-p)
           (dired-next-line 1)
           (dired-subtree-remove))))

     (use-package dired-ranger
       :general
       ('normal dired-mode-map
                "gc" #'dired-ranger-copy
                "gm" #'dired-ranger-move
                "gp" #'dired-ranger-paste))
   #+END_SRC

** Git
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :general
       (panda-space "g" #'magit-status)
       :config
       (gsetq magit-auto-revert-mode nil))

     (use-package magit-todos
       :after magit
       :config
       (gsetq magit-todos-rg-extra-args '("--hidden" "--glob" "!.git/"))
       (magit-todos-mode))

     (use-package forge :after magit)

     (use-package evil-magit :after magit)

     (use-package git-timemachine
       :general (panda-space "G" #'git-timemachine))
   #+END_SRC

** Readers
   #+BEGIN_SRC emacs-lisp
     (defun panda-configure-image-view ()
       "Configure settings for viewing an image."
       (display-line-numbers-mode -1)
       (gsetq-local evil-default-cursor (list nil)))

     (add-hook 'image-mode-hook #'panda-configure-image-view)
     (add-hook 'image-dired-display-image-mode-hook #'panda-configure-image-view)

     (use-package elfeed
       :defer t
       :config
       (gsetq elfeed-search-title-max-width 100
              elfeed-search-filter "@1-month-ago"))

     (use-package nov
       :mode ("\\.epub$" . nov-mode)
       :gfhook '(visual-line-mode)
       :config
       (gsetq nov-text-width most-positive-fixnum))

     (use-package pdf-tools
       :disabled t
       :mode ("\\.pdf$" . pdf-view-mode)
       :gfhook ('pdf-view-mode-hook '(panda-configure-image-view))
       :config
       (gsetq-default pdf-view-display-size 'fit-page)
       (pdf-tools-install))
   #+END_SRC

** Shell
   I prefer using ~kitty~, but having access to ~zsh~ in Emacs can be useful for
   one-off commands.

   #+BEGIN_SRC emacs-lisp
     (use-package vterm :defer t)

     (use-package vterm-toggle
       :general
       (panda-space "<return>" #'panda-vterm-toggle-cd)
       :config
       (add-to-list 'display-buffer-alist
                    '((lambda (buffer-name _)
                        (with-current-buffer buffer-name
                          (equal major-mode 'vterm-mode)))
                      (display-buffer-in-side-window)
                      (side . bottom)
                      (window-height . 15)
                      (dedicated . t)))
       ;; `vterm-toggle-cd' doesn't cd sometimes
       (defun panda-vterm-toggle-cd ()
         (interactive)
         (call-interactively #'vterm-toggle)
         (vterm-toggle-insert-cd)))
   #+END_SRC

   I don't really use ~eshell~ as much.

   #+BEGIN_SRC emacs-lisp
     (use-package eshell
       :defer t
       :config
       (gsetq eshell-hist-ignoredups t
              eshell-history-size 1024))

     (use-package esh-autosuggest
       :ghook 'eshell-mode-hook)
   #+END_SRC

* Languages
  I bind all language-specific commands through ~major-mode-hydra~, since I
  sometimes forget a command's keybinding or even name.

  #+BEGIN_SRC emacs-lisp
    (use-package major-mode-hydra
      :demand t
      :general
      ('(normal visual) "\\" 'major-mode-hydra)
      :config
      (defun panda-major-mode-hydra-title (major-mode)
        (format "Major Mode Hydra (%s)" major-mode))
      (gsetq major-mode-hydra-invisible-quit-key "<escape>"
             major-mode-hydra-title-generator #'panda-major-mode-hydra-title))
  #+END_SRC

** Assembly
   #+BEGIN_SRC emacs-lisp
     (use-package asm-mode
       :defer t
       :gfhook '(asmfmt-on-save-mode panda-set-asm-locals)
       :config
       (defun panda-set-asm-locals ()
         (gsetq-local asm-comment-char ?#)
         (gsetq-local indent-tabs-mode t)
         (gsetq-local tab-always-indent t))
       (reformatter-define asmfmt
         :program "asmfmt"))
   #+END_SRC

** C / C++
   #+BEGIN_SRC emacs-lisp
     (use-package cc-mode
       :defer t
       :gfhook ('(c-mode-hook c++-mode-hook)
                '(clang-format-on-save-mode panda-set-c-locals))
       :config
       (defun panda-set-c-locals ()
         (c-set-offset 'innamespace 0))
       (reformatter-define clang-format
         :program "clang-format"
         :args (when-let ((file (buffer-file-name)))
                 (list "--assume-filename" file))))

     (use-package ccls
       :ghook ('(c-mode-hook c++-mode-hook)
               (lambda () (require 'ccls) (lsp-deferred)))
       :mode-hydra
       ((c-mode c++-mode)
        nil
        ("View"
         (("m" ccls-member-hierarchy "Member Hierarchy")
          ("C" ccls-call-hierarchy "Call Hierarchy")
          ("I" ccls-inheritance-hierarchy "Inheritance Hierarchy"))
         "Preview"
         (("p" ccls-preprocess-file "Preprocessed File")))))

     (use-package highlight-doxygen
       :ghook ('(c-mode-hook c++-mode-hook) '(highlight-doxygen-mode))
       :custom-face
       (highlight-doxygen-comment ((t nil)))
       (highlight-doxygen-code-block ((t nil))))

     (use-package ggtags :defer t)

     (use-package rmsbolt
       :ghook ('(c-mode-hook c++-mode-hook) '(panda-turn-on-rmsbolt-with-llvm))
       :mode-hydra
       ((c-mode c++-mode)
        nil
        ("Preview"
         (("a" rmsbolt-compile "LLVM IR"))))
       :config
       (gsetq rmsbolt-asm-format nil
              rmsbolt-filter-comment-only nil
              rmsbolt-filter-directives nil
              rmsbolt-filter-labels nil)
       (defun panda-turn-on-rmsbolt-with-llvm ()
         "Enable `rmsbolt-mode' for LLVM IR."
         (gsetq-local rmsbolt-command "clang -emit-llvm")
         (rmsbolt-mode)))
   #+END_SRC

** C#
   #+BEGIN_SRC emacs-lisp
     (use-package csharp-mode
       :defer t
       :gfhook '(lsp-deferred panda-format-on-save-mode))
   #+END_SRC

** Common Lisp
   #+BEGIN_SRC emacs-lisp
     (use-package lisp-mode
       :straight nil
       :defer t
       :gfhook '(lispyville-mode
                 panda-format-on-save-mode
                 panda-set-lisp-locals)
       :config
       (defun panda-set-lisp-locals ()
         (gsetq panda-inner-defun-bounds '("(" . ")"))))

     (use-package slime
       :defer t
       :mode-hydra
       (lisp-mode
        nil
        ("Eval"
         (("eb" slime-eval-buffer "Buffer")
          ("ed" slime-eval-defun "Defun")
          ("ee" slime-eval-last-expression "Expression")
          ("er" slime-eval-region "Region")
          ("eo" slime "Open REPL"))
         "Debug"
         (("m" macrostep-expand "Macrostep"))))
       :config
       (gsetq inferior-lisp-program "sbcl"
              slime-contribs '(slime-fancy))
       (slime-setup))

     (use-package slime-company
       :after slime
       :config
       (slime-company-init))
   #+END_SRC

** Emacs Lisp
   #+BEGIN_SRC emacs-lisp
     (use-package elisp-mode
       :straight nil
       :defer t
       :gfhook ('emacs-lisp-mode-hook '(lispyville-mode
                                        panda-format-on-save-mode
                                        panda-set-elisp-locals))
       :mode-hydra
       ((emacs-lisp-mode lisp-interaction-mode)
        nil
        ("Eval"
         (("eb" eval-buffer "Buffer")
          ("ed" eval-defun "Defun")
          ("ee" eval-last-sexp "Expression")
          ("er" eval-region "Region")
          ("eo" ielm "Open REPL"))
         "Compile"
         (("c" byte-compile-file "File"))
         "Check"
         (("C" checkdoc "Checkdoc"))
         "Debug"
         (("E" toggle-debug-on-error "On Error")
          ("q" toggle-debug-on-quit "On Quit")
          ("d" debug-on-entry "On Entry")
          ("D" cancel-debug-on-entry "Cancel On Entry"))
         "Test"
         (("t" ert "Run"))))
       :config
       (defun panda-set-elisp-locals ()
         (gsetq panda-inner-defun-bounds '("(" . ")"))))

     (use-package macrostep
       :mode-hydra
       ((emacs-lisp-mode lisp-interaction-mode)
        nil
        ("Debug"
         (("m" macrostep-expand "Macrostep")))))

     (use-package package-lint
       :mode-hydra
       ((emacs-lisp-mode lisp-interaction-mode)
        nil
        ("Check"
         (("p" package-lint-current-buffer "package-lint")))))
   #+END_SRC

** Go
   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :defer t
       :gfhook '(golines-on-save-mode lsp-deferred panda-set-go-locals)
       :config
       (defun panda-set-go-locals ()
         (gsetq indent-tabs-mode t))
       (defvar golines-args '("--max-len" "80")
         "Arguments for golines.")
       (reformatter-define golines
         :program "golines"
         :args golines-args))
   #+END_SRC

** Haskell
   I would use HIE or ghcide, but I'm too lazy to install them.

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :defer t
       :gfhook '(brittany-on-save-mode)
       :mode-hydra
       (("Eval"
         (("ef" haskell-process-load-file "File")
          ("eo" haskell-interactive-switch "Open REPL"))
         "Navigate"
         (("i" haskell-navigate-imports "Imports"))
         "Compile"
         (("c" haskell-compile "Project"))))
       :config
       (gsetq haskell-ask-also-kill-buffers nil
              haskell-compile-cabal-build-command "stack build"
              haskell-process-type 'stack-ghci)
       (reformatter-define brittany
         :program "brittany"))

     (use-package attrap
       :mode-hydra
       (haskell-mode nil ("Refactor" (("f" attrap-attrap "Fix Error")))))

     (use-package dante
       :ghook 'haskell-mode-hook
       :mode-hydra
       (haskell-mode
        nil
        ("Eval"
         (("ee" dante-eval-block "Block"))
         "View"
         (("I" dante-info "Info")
          ("t" dante-type-at "Type"))
         "Dante Process"
         (("<backspace>" dante-restart "Restart")
          ("<delete>" dante-destroy "Shutdown"))))
       :config
       (flycheck-add-next-checker 'haskell-dante '(warning . haskell-hlint)))
   #+END_SRC

** HTML / CSS
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :mode (("\\.html?\\'" . web-mode))
       :gfhook '(lsp-deferred prettier-html-on-save-mode)
       :init
       (gsetq web-mode-enable-auto-closing t
              web-mode-enable-auto-indentation t
              web-mode-enable-auto-opening t
              web-mode-enable-auto-pairing t
              web-mode-enable-auto-quoting t
              web-mode-enable-css-colorization t
              web-mode-markup-indent-offset 2
              web-mode-style-padding 4
              web-mode-script-padding 4
              web-mode-block-padding 4)
       :config
       (reformatter-define prettier-html
         :program "prettier"
         :args '("--stdin" "--parser" "html")))

     (use-package css-mode
       :defer t
       :gfhook '(lsp-deferred prettier-css-on-save-mode)
       :config
       (reformatter-define prettier-css
         :program "prettier"
         :args '("--stdin" "--parser" "css")))

     (use-package emmet-mode
       :ghook '(web-mode-hook css-mode-hook))
   #+END_SRC

** JavaScript / TypeScript
   #+BEGIN_SRC emacs-lisp
     (use-package js
       :defer t
       :gfhook '(lsp-deferred prettier-ts-on-save-mode))

     (use-package rjsx-mode :defer t)

     (use-package typescript-mode
       :defer t
       :gfhook '(lsp-deferred prettier-ts-on-save-mode))

     (reformatter-define prettier-ts
       :program "prettier"
       :args '("--stdin" "--parser" "typescript"))
   #+END_SRC

** JSON
   ~json-mode~ inherits from ~js-mode~.  That's something to be careful about.

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode
       :defer t
       :gfhook '(prettier-json-on-save-mode)
       :config
       (reformatter-define prettier-json
         :program "prettier"
         :args '("--stdin" "--parser" "json")))
   #+END_SRC

** Latex
   #+BEGIN_SRC emacs-lisp
     (use-package tex
       :straight auctex
       :defer t
       :gfhook ('LaTeX-mode-hook '(panda-format-on-save-mode))
       :config
       (gsetq TeX-auto-save t
              TeX-parse-self t))

     (use-package evil-tex
       :ghook 'LaTeX-mode-hook)
   #+END_SRC

** Matlab
   #+BEGIN_SRC emacs-lisp
     (use-package matlab-mode
       :defer t
       :gfhook '(panda-format-on-save-mode)
       :mode-hydra
       (("Eval"
         (("ec" matlab-shell-run-cell "Cell")
          ("el" matlab-shell-run-region-or-line "Line or Region")
          ("eo" matlab-shell "Open REPL")))))
   #+END_SRC

** Org
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :straight (:type built-in)
       :gfhook '(panda-format-on-save-mode)
       :general
       (panda-space
         "a" 'org-agenda
         "A" 'org-capture)
       :config
       (defun panda-goto-agenda-top-level-heading ()
         "Go to a top\-level agenda heading that isn't a TODO."
         (interactive)
         (let* ((file (completing-read "Select agenda file: " (org-agenda-files)))
                (headings (org-map-entries (lambda () (org-entry-get (point) "ITEM"))
                                           "LEVEL=1+TODO=\"\""
                                           (list file)))
                (selected-heading (completing-read "Select heading: " headings nil t)))
           (find-file file)
           (goto-char (point-min))
           (re-search-forward (format "^\\*[[:space:]]+%s[[:space:]]*$" selected-heading))))

       (gsetq org-directory "~/org")
       (gsetq org-agenda-custom-commands
              '(("n" "Agenda and unscheduled tasks"
                 ((agenda "" ((org-agenda-span 1)))
                  (alltodo "" ((org-agenda-overriding-header "Unscheduled Tasks:")
                               (org-agenda-skip-function
                                '(org-agenda-skip-entry-if 'timestamp)))))))
              org-agenda-files (list (expand-file-name "agenda" org-directory))
              org-capture-templates
              '(("e" "Event" entry (function panda-goto-agenda-top-level-heading)
                 "** %?\n   SCHEDULED: <%(org-read-date nil nil \"+1\")>")
                ("d" "Deadline" entry (function panda-goto-agenda-top-level-heading)
                 "** TODO %?\n   DEADLINE: <%(org-read-date nil nil \"+1\")>")
                ("s" "Scheduled Task" entry (function panda-goto-agenda-top-level-heading)
                 "** TODO %?\n   SCHEDULED: <%(org-read-date nil nil \"+1\")>")
                ("t" "Undated Task" entry (function panda-goto-agenda-top-level-heading)
                 "** TODO %?"))
              org-catch-invisible-edits 'error
              org-src-fontify-natively t
              org-src-tab-acts-natively t)
       (plist-put org-format-latex-options :scale 1.5))

     (use-package toc-org
       :ghook 'org-mode-hook)

     (use-package org-bullets
       :ghook 'org-mode-hook)

     (use-package org-projectile
       :after org
       :config
       (gsetq org-projectile-projects-file (expand-file-name "projects.org" org-directory)
              org-projectile-counts-in-heading nil
              org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
       (add-to-list 'org-capture-templates (org-projectile-project-todo-entry) t #'equal))

     (use-package evil-org
       :demand :after org
       :ghook 'org-mode-hook
       :config
       (evil-org-set-key-theme '(additional calendar insert navigation))
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))

     (use-package olivetti :defer t)
   #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
     (use-package python
       :defer t
       :gfhook '(black-on-save-mode panda-set-python-locals)
       :mode-hydra
       (python-mode
        ("Eval"
         (("eb" python-shell-send-buffer "Buffer")
          ("ed" python-shell-send-defun "Defun")
          ("ef" python-shell-send-file "File")
          ("er" python-shell-send-region "Region")
          ("eo" run-python "Open REPL"))))
       :config
       (gsetq python-indent-offset 4)
       (defun panda-set-python-locals ()
         (gsetq panda-inner-defun-bounds '(":" . ""))
         (gsetq-local yas-indent-line 'fixed)
         (gsetq-local yas-also-auto-indent-first-line nil))
       (progn
         (defvar black-args '("--line-length" "80")
           "Arguments for black.")
         (reformatter-define black
           :program "black"
           :args (append '("-" "--quiet") black-args))))

     (use-package lsp-pyright
       :defer t
       :ghook ('(python-mode-hook) (lambda () (require 'lsp-pyright) (lsp-deferred))))
   #+END_SRC

** R
   #+BEGIN_SRC emacs-lisp
     (use-package ess
       :defer t
       :gfhook ('ess-r-mode-hook '(panda-format-on-save-mode))
       :general
       ('normal ess-r-mode-map "K" #'ess-help)
       :mode-hydra
       (ess-r-mode
        ("Eval"
         (("eb" ess-eval-buffer "Buffer")
          ("ed" ess-eval-function "Function")
          ("ef" ess-load-file "File")
          ("el" ess-eval-line "Line")
          ("ep" ess-eval-paragraph "Paragraph")
          ("er" ess-eval-region "Region")
          ("eo" R "Open REPL"))))
       :init
       (gsetq ess-indent-with-fancy-comments nil)
       :config
       (gsetq ess-ask-for-ess-directory nil))

     (use-package poly-R
       :defer t
       :gfhook ('poly-markdown+r-mode-hook '(markdown-toggle-math)))

     (use-package ess-smart-equals
       :after ess
       :config
       (ess-smart-equals-activate))

     (use-package ess-view-data
       :mode-hydra
       (ess-r-mode
        ("View"
         (("d" ess-view-data-print "Data"))))
       :general
       ('normal ess-view-data-mode-map
                "C-j" #'ess-view-data-goto-next-page
                "C-k" #'ess-view-data-goto-previous-page
                ;; TODO: would be better as a pretty-hydra
                "zc" #'ess-view-data-count
                "zf" #'ess-view-data-filter
                "zn" #'ess-view-data-select
                "zN" #'ess-view-data-unselect
                "zo" #'ess-view-data-overview
                "zr" #'ess-view-data-reset
                "zs" #'ess-view-data-sort
                "zu" #'ess-view-data-unique))
   #+END_SRC

** Shell Script
   #+BEGIN_SRC emacs-lisp
     (use-package sh-script
       :straight (:type built-in)
       :defer t
       :gfhook ('sh-mode-hook '(panda-set-up-sh-mode))
       :config
       (progn
         (defvar shfmt-args '("-ci" "-i" "4")
           "Arguments for shfmt.")
         (reformatter-define shfmt
           :program "shfmt"
           :args shfmt-args))
       (defun panda-set-up-sh-mode ()
         (unless (eq sh-shell 'zsh)
           (lsp-deferred)
           (shfmt-on-save-mode))))
   #+END_SRC

** Other
   These are languages I only need syntax highlighting for.

   #+BEGIN_SRC emacs-lisp
     (use-package bazel-mode :defer t)
     (use-package cmake-mode :defer t)
     (use-package csv-mode :defer t)
     (use-package d-mode :defer t)
     (use-package fish-mode :defer t)
     (use-package gitattributes-mode :defer t)
     (use-package gitconfig-mode :defer t)
     (use-package gitignore-mode :defer t)
     (use-package kotlin-mode :defer t)
     (use-package llvm-mode
       :straight (llvm-mode
                  :host github
                  :repo "llvm/llvm-project"
                  :files ("llvm/utils/emacs/llvm-mode.el")
                  :depth 1
                  :nonrecursive t)
       :defer t)
     (use-package markdown-mode :defer t)
     (use-package protobuf-mode
       :straight (protobuf-mode
                  :host github
                  :repo "protocolbuffers/protobuf"
                  :files ("editors/protobuf-mode.el")
                  :depth 1
                  :nonrecursive t)
       :defer t)
     (use-package rust-mode :defer t)
     (use-package vimrc-mode :defer t)
     (use-package yaml-mode :defer t)
   #+END_SRC

* Stuff To Check Out
  Packages:

  - evil-cleverparens
  - exato
  - go-impl
  - go-tag
  - gorepl-mode
  - gotest
  - lsp-origami
  - org-superstar
  - poly-org
  - project.el
  - undo-fu-session
